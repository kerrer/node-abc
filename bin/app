#!/usr/bin/env node
/*
 * node bin/app -p 5555 -d
 * forever start -a -d bin/app -p 5555
 * pm2 start bin/app -- -p 5555
 */
 
var fs =  require('fs'),
    path = require('path'),
	S = require('string'),
	grunt = require('grunt'),
    watch = require('watch');
var _ = require('lodash');
var program = require('commander');
var forever = require('forever');
var detect = require('detect-port');
var  ip = require('ip');
var fork = require('child_process').fork, grunt_child;

var Service;
var pkg= JSON.parse(fs.readFileSync('package.json'));
forever.load({root:path.join(process.env.PWD,'.forever'),debug:true});

var env = process.env.NODE_ENV = process.env.NODE_ENV || "development";
process.env.CONF_DIR= path.resolve(env === "production" ?  __dirname + "/../services" : __dirname + "/../target/services" );
process.env.SVR_DIR = path.resolve(env === "production" ?  __dirname + "/../services" : __dirname + "/../target/services" );

program
	.version('0.0.1');

if(S(process.env._).endsWith('node') || S(process.env._).endsWith('app')){
	var cmdValue;
	 program
		.arguments('<cmd> [otherOpts...]')
		.action(function (cmd, otherOpts) {
			cmdValue = cmd;
		});
		
	program
		.command('start')
		.description('启动服务')
		.option('-p, --port [port]', '服务运行端口','5004')
		.option('-h, --host [host]', '服务绑定的ip地址',ip.address())
		.option('-eh, --etcd_host [etcd_host]', '注册中心ip地址','127.0.0.1')
		.option('-ep, --etcd_port [etcd_port]', '注册中心连接端口','4001')
		.option('-t, --thread [thread]', '运行的线程数',1)
		.option('-d, --deamon', '开始deamon运行')
		.option('-w, --watch', '自动构建源码')
		.option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')
		.action(function(options){
			cmdValue="start";
			console.log('服务启动中....................');
			start(options);
		});
   
	program
		.command('shutdown')
		.description('停止服务')
		.action(function(){		
			cmdValue="shutdown";
			shutdown();
		});

	program.on('--help', function(){
		console.log('  Examples:');
		console.log('');
		console.log('    $ bin/app --help');
		console.log('    $ bin/app -h');
		console.log('');
	});
	
	program.parse(process.argv);

	if (typeof cmdValue === 'undefined') {
		program.help();
		process.exit(1);
	}
	if (_.indexOf(['start','shutdown'], cmdValue)===-1) {
		console.log(cmdValue,': 没有此命令或该命令无法识别，请使用‘bin/app --help’获取帮助');
		process.exit(1);
	}

}else{
	program
		.option('-p, --port [port]', '服务运行端口','5004')
		.option('-h, --host [host]', '服务绑定的ip地址',ip.address())
		.option('-eh, --etcd_host [etcd_host]', '注册中心ip地址','127.0.0.1')
		.option('-ep, --etcd_port [etcd_port]', '注册中心连接端口','4001')
		.option('-t, --thread [thread]', '运行的线程数')
		.parse(process.argv);
	
	start(program);	
}

function start(options){
	var port = options.port;
	var host =options.host;
	var etcd_host=options.etcd_host;
	var etcd_port=options.etcd_port;
	var tvs=options.thread;
	var run_deamon=options.deamon;
	var watch=options.watch;
    var promisePort = detect(port);
    var name=pkg.name;

    promisePort.then(function(_port) {
		if (port !== _port) {
			console.log('服务端口:%d已被占用, 可以试用端口: %d', port, _port);
			return;
		}
		console.log("使用注册中心:",etcd_host,etcd_port);		
		switch (true){
			case process.env.pmx || S(process.env._).endsWith('pm2'):
				require('services')(etcd_port,etcd_host).server(port,program.host).start(name,true);break;
			case S(process.env._).endsWith('node'):
			case S(process.env._).endsWith('app'):
				if(run_deamon){
					var compiled=_.template("require('services')(<%= etcd_port %>,'<%= etcd_host %>').config({instances:<%= instances %>}).server(<%= port %>,'<%= host %>').start('<%= name %>');");
					var deamon_content = compiled({ 'port': port,'host':host, 'etcd_host':etcd_host, 'etcd_port':etcd_port,'name':name,'instances':tvs});
					var deamon_file=path.join(__dirname,'..','.forever' , name +'.js');
					fs.writeFile(deamon_file, deamon_content,'utf8', function (err) {
						if (err) {
							console.log("file error");
							throw err;
						}
						forever.startDaemon(deamon_file,{
							max: 3,
							silent: true
						});
					});					
				}else{
					run_cli();
					Service = require('services')(etcd_port,etcd_host);						
					if(env === "production"){
						Service.config({instances:tvs})
					}else{
						watch  ? watch_build() :null;							
					}
		
					Service.server(port,host).start(name);
				}
				break;
			case S(process.env._).endsWith('forever'):
				require('services')(etcd_port,etcd_host).config({instances:tvs}).server(port,host).start(name);
				break;
			default:
				break;
		}//switch		
	});//promisePort
}

function shutdown(){
	console.log('服务停止中....................');
	forever.stop();
}

function stop(){
   setTimeout(function() {
     Service.stop();	
   }, 3000);      
}

function reload(){
	if(Service){
		Service.reload();
	}		
}

function restart(){
   console.log("restart services................");
   setTimeout(function() {
      Service.restart();	
   }, 1000);     
}

function exit(n){
	 setTimeout(function(){
        process.exit();
     }, n);
}

function normalizePort(val) {
	  var port = parseInt(val, 10);
	  if (isNaN(port)) {
	    // named pipe
	    //return val;
	    return false;
	  }

	  if (port >= 0) {
	    // port number
	    return port;
	  }
	  return false;
}

function run_cli(){
	process.on('uncaughtException', function(err) {
		console.log('Caught exception: ' + err.message,err.stack);
	});
	
	process.on('exit', function(code) {
		// do *NOT* do this
		setTimeout(function() {
			console.log('This will not run');
		}, 0);
		console.log('app start About to exit with code:', code);
	});
	
	var unhandledRejections = new Map();
	process.on('unhandledRejection', function(reason, p) {
		console.log("unhandledRejection");
		unhandledRejections.set(p, reason);
	});
	
	process.on('rejectionHandled', function(p) {
		console.log("rejectionHandled");
		unhandledRejections.delete(p);
	});
	
	if (process.platform === "win32") {
		var rl = require("readline").createInterface({
			input: process.stdin,
			output: process.stdout
		});

		rl.on("SIGINT", function () {
			process.emit("SIGINT");
		});
	}

	process.on("SIGINT", function () {
		console.log('shutdown');
		process.exit();
	});
}

function watch_build(){
	grunt_child = fork(__dirname+'/grunt.js');
	grunt_child.on('message',function(obj){
		if(obj.type && obj.type==='grunt'){
			if(obj.data && obj.data==="reload"){
				reload();
			}
		}
	});
	//grunt_child.send({type:'main',data:'newbuild'});

	watch.watchTree('./src', function (f, curr, prev) {
		if (typeof f == "object" && prev === null && curr === null) {
			console.log("watching.........................");
		} else if (prev === null) {
			// f is a new file
			rebuild(f);
		} else if (curr.nlink === 0) {
			// f was removed
			rebuild(f);
		} else {
			// f was changed
			rebuild(f);
		}
	});	
}

function rebuild(file){
    if(S(file).startsWith("src/test")){
		  grunt_child.send({type:'test',data:'rebuild'});
	}else{
		  grunt_child.send({type:'main',data:'rebuild'});
	}
}
